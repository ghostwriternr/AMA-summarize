Hello,  so I heard you guys wrote the Linux Intel Vulkan driver. How many source lines of code approx. is the userland implementation of that?
I know you like technical questions, but I have to ask, where do you see gaming in 5 years? 25 years?
Hey, thanks guys for having an AMA.  Is there a release date for the (open source) Intel Linux driver? 
The driver is substantially smaller than the Mesa driver.  About 27k lines of code for the driver (not counting the compiler) 
Hi!  How do you see Vulkan affecting Linux graphics stack in the light of OpenGL  Vulkan transition? For example will it fit into Mesa project or produce something new? Also, what can happen with APIs like EGL which assume OpenGL stateful architecture, when Vulkan presents new stateless approach? Will EGL have to be replaeced with Vulkan based alternative? And how might that affect projects like Wayland?  Thanks!
What is your opinion of the current state of Linux drivers and its future? Especially, Mesa and Gallium3D.
How hard will it be to move codebases between OpenCL and Vulkan? Will OpenCL C++ be able to compile to and run as Vulkan shaders? From the SPIR-V spec, I saw that programs have specific capability sets, including one for CL kernels and one for VK shaders, despite both APIs using SPIR-V.  What kind of extensions can we expect to see for SPIR-V, and will it be supported by other APIs than OpenCL and Vulkan?  How much do you think existing game engines and toolkits will have to change to reflect the full flexibility of Vulkan? Will we need entirely new abstractions, and how hard is it to support the old ones?
The day the spec is publicly available, we plan to release source code.
To and from SPIR-V added about 8k lines of compiler code.
How does context creation work with Vulkan?
Would it be possible (and desirable if possible) to implement OpenGL on top of Vulkan, so that we get a vendor neutral OpenGL implementation that can be used by any driver that supports Vulkan? For me that sounds better than having good, bad and mediocre implementations of OpenGL across vendors that have to be maintained and fixed per vendor .
OpenGL will live on...it serves a key purpose.  EGL will live on with OpenGL.  The Vulkan window system interface is still being discussed.  Vulkan is targeted for explicit control over the GPU for minimal overhead in the driver.
Like OpenGL, Mesa will live on.  It plays a vital role in our ecosystem.
I guess the compiler is something that can be easily shared between drivers (open source AMD for example) without extra code?
Hi,  In the newer version of OpenGL some things were added to approach zero driver overhead, are we going top see things like multi_draw_indirect in Vulkan?
[deleted]
&gt; The Vulkan window system interface is still being discussed.  That's interesting.  &gt; OpenGL will live on...it serves a key purpose. EGL will live on with OpenGL.  What purpose do you see for OpenGL in the future besides supporting legacy applications? I got an impression that Vulkan proposes new application design that is geared towards increasing hardware parallelism, while OpenGL is restricted by design in that regard. So I'd assume that for any new projects it's advisable to use Vulkan (and build whatever is needed on their own on top of that). I.e. no matter whether it's games or graphics servers and windowing systems. Or you consider OpenGL useful for future projects too in some cases?
One of the really bad itches with the Linux OpenGL ABI is, that the `libGL.so` in the linker path is to be provided by the driver. This makes it close to impossible to use multiple GPUs of different vendors in the same runtime environment (it has always been possible to launch programs in different REs on the same system (different X server, different linker path or container), thereby linking to different `libGL.so`).  In light of that, the mechanism of Windows, using OpenGL ICDs that are hooked into by `opengl32.dll` is a much easier to work with approach.  Vulkan has the clearly stated mission goal for allowing seamless heterogenous multi GPU support. While I can think of a number of ways, this can be implemented, I'm curious on what your approach on the actual implementation would be?  (EDIT: missing words added).
daily weapon battles when
:(  Pls go. It's on my to do list on my iphone.
&gt; How hard will it be to move codebases between OpenCL and Vulkan?  They are still different operating environments, with different programming models, but convergence will occur over time.  Tools can be shared.  
What context? :-)  There are no contexts in Vulkan. Everything works on objects that are passed around across the API.
We think this is a really good idea...but we don't think it is easy. We expect to see native OpenGL implementations continue for a while.
How much simpler is a driver that only implements Vulkan compared to a driver that only implements OpenGL, all other factors being the same?
I think OP means the handle(s) to the GPUs/compute devices. Eventually the command buffers have to be submitted *somewhere*.
Yes.  Vulkan started with the concept of minimizing driver overhead.
We are developing a common loader to work across multiple simultaneous vendor's GPUs.  This is not just for our driver, or a handful of select vendors.  This is designed to address the cross vendor challenge you identify so well here. 
Implementations will vary a lot...depending on architecture, etc: 77.2% :-) The compiler frontend doesn't have to be there...which is about 40k lines of code.
In the Khronos session at GDC they mentioned the concept of a "loader library, initialized with vkCreateInstance()", which to me sounded a lot like a jump-table based approach similar to how OpenGL operates on Windows and how the [new OpenGL ABI on Linux was proposed](https://github.com/NVIDIA/libglvnd)
More like your personal opinion, you guys have done quite a bit for the open source graphics stack on Linux. Below are some more explicit questions.  In which ways is open source graphics community stack growing now with SteamOS pushing Linux into mainstream video gaming.   When do you think Mesa will have full support for OpenGL (through 4.5)?  Do your feel that open source Linux drivers in the future would eventually be better than any proprietary ones? In my opinion, graphic drivers have become too complex for one company to create.
"Not counting the compiler" is referring to the GLSL-&gt;SPIR-V compiler and not the SPIR-V -&gt; hardware ISA assembler, yes?
OpenGL is easier to use, so that's going to stay around for a while.  We heard the comment that writing a Vulkan backend for an engine is pretty much like writing an OpenGL driver that only does what you want it to do.
&gt; What kind of extensions can we expect to see for SPIR-V, and will it be supported by other APIs than OpenCL and Vulkan?  We think it would be great if SPIR-V is supported by more API's than just Vulkan and OpenCL.  Existing OpenGL extensions will be added to SPIR-V, if needed by Vulkan.
[deleted]
Now that DirectX 12 is lacking the features of Vulkan, do you see it finally becoming the standard for...everywhere, instead of being the "ketchup" API? Do you believe DirectX 12 will under-perform when compared to Vulkan?
GLSL -&gt; SPIR-V can be shared across ISVs.  SPIR-V -&gt; target is vendor specific. 
Huh?
That makes sense, on the other hand engines and projects which care about performance will probably want to avoid limitations of OpenGL. May be some middle layer can emerge which can provide higher level abstraction than Vulkan and address some common needs, but on the other hand won't be restricted by OpenGL design?  Using OpenGL just for the sake of simplicity sounds like poor man solution in this case because of the lack of alternaives (since major tradeoff is performance).
It's not counting anything in the compiler stack 
Hi!   Can Vulkan improve performance of non-gaming applications as 3D modelers or CADs (huge polygon count, near zero lighting effects and often no texturing)? 
Will Vulkan be able to use the VRAM of both cards in a multi GPU system? Could NVIDIA and AMD cards work together making SLI/Crossfire obsolete?
Are you willing to hazard a guess as to when that might be?
&gt; In which ways is opens source graphics community stack improving now with SteamOS pushing Linux into mainstream video gaming.  Getting OpenGL up to parity for Mesa is alot of work.  With Vulkan we are there out of the gate.
WebVulkan? Do you foresee any additional challenges in potentially bringing Vulkan to Javascript in contrast to WebGL/OpenGL? JS is ultimately single-threaded.
&gt; Do your feel that open source Linux drivers in the future would eventually be better than any proprietary ones? In my opinion, graphic drivers have become too complex for one company to create.  Yes, with the caveat that there is a similar level of investment.
wot
sorry
There are devices, queues, command buffers and pipelines.
Khronos said that it will be this year. If they think they need another month to get it right they will delay the release another month. There is no timeframe.
Vulkan supports multiple threads talking with it at the same time, but is there any support for multiple processes doing so?
 Vulkan approaches Zero Overhead...
[deleted]
Yes, NVidia gave a CAD demo at GDC using Vulkan
Thank you for doing this AMA.  * How are you envisioning extension support for Vukan? Will it be similar to OpenGL where you check for availability and then GetProcAddress the entry points?  * In the Khronos session, it was explained that you would have to manually opt in to any extensions. Does that mean that, for example, if an extension provides an additional texture format, the driver has to validate every time textures are created whether the format extension was opted-into or not? Or is the behavior in such a case simply undefined and responsibility pushed to the debug layers to catch this?  * What additions to the Intel DRM driver were necessary to make it work with Vulkan?  * What are "descriptor set pools"? From what I have read elsewhere, it's a special kind of memory heap to allocate descriptor sets from, but why would you need to reference the pool explicitly? In what kind of scenarios would you be using multiple pools?  * What was the rationale behind pipeline objects being serializable, what is the use case for this? Are serialized pipeline vendor/driver/device(context) specific?  * Why are you using the two terms "event" and "fence" if they're more or less the same thing? Isn't a fence just an event signalled automatically when a commandbuffer has finished executing?  * What does "querying the GPU memory requirements for images" entail? It sounded a bit like you would need to allocate memory from multiple pools for one image, is that the case? And when would an image require a different pool than usual, is it based on size?  * Will there be a distinction between textures and renderbuffers as offscreen rendertargets in Vulkan, or does that not make sense anymore on modern hardware?  That's all I could think of off the top of my head, thanks in advance for answering.
Probably the biggest question right now: when is Vulkan expected to ship and on what OS's/hardware? I understand that you might not know everything, but you're showing off this really cool stuff with no indication of when or where we can use it. Can you at least give a hint?
That is the target...but it will place a significant effort on app developers to make this work well.
how do the "pipelines" work?
It's been discussed...we'll see.
Is UEFI boot support always going to be a requirement? I have a bunch of semi-decent hardware that can't be used because of this requirement.
Will Vulkan work with old and existing video cards and GPUs or will only new GPUs have support for it?
When you say you don't think it would be easy, are you thinking of a full OpenGL compatibility profile, or just the core profile?  It seems like the latter would be significantly easier.  
Resource sharing works best within a single process...multiple apps will work concurrently, just as they do today with OpenGL.
    vkCreateInstance();     vkEnumerateGpus();     vkWsiX11AssociateConnection();     vkCreateDevice();  something similar to that I guess. Left out all parameters / structs for simplicitly. Only the third call actually takes your window handle.     
&gt; With Vulkan we are there out of the gate.  And for that, I thank you! No more catch up for the Linux desktop. We will be ready day 1 (at least with Intel) :D!!  Edit: clarification
Then how do you bridge the gap between 'I have rendering code which will draw something' and 'I have a client area on a OS native window on which to draw it'? 
&gt; How are you envisioning extension support for Vukan? Will it be similar to OpenGL where you check for availability and then GetProcAddress the entry points?  Yes, applications are required to specify extensions they want to use.
[deleted]
&gt; In the Khronos session, it was explained that you would have to manually opt in to any extensions. Does that mean that, for example, if an extension provides an additional texture format, the driver has to validate every time textures are created whether the format extension was opted-into or not? Or is the behavior in such a case simply undefined and responsibility pushed to the debug layers to catch this?  No, it's not every time it is created.  It is only at CreateDevice time.
If your thinking that Nvidia = good OpenGL driver, then I have to disappoint you; it's not that their driver is clean and well written, but that they have thousands of man hours more than AMD poured into writing per-game hacks and workarounds.  I'd imagine an OpenGL implementation on top of Vulkan would perform similarly to open source drivers (so not bad, but definitely not proprietary level).
It was said on GDC that it will work on hardware which supports OpenGL ES 3.1. For Intel it's from Haswell and up if I understood correctly.
http://vulkan-tutorial.com/assets/Khronos-Vulkan-GDC-Mar15.pdf
Could parts of your Intel Vukan code be ported to windows, or does it rely heavily on some dependencies?
[deleted]
Cool! So, something like NVidia's NVPath extension could be written for Vulkan?
How does Vulcan compare to Gallium3D architecture?  Would it make any sense to develop Vulcan on top of Gallium3D or use it as the basis for a Gallium3D 2.0?
&gt; What additions to the Intel DRM driver were necessary to make it work with Vulkan?  We did not have to make any changes to the kernel DRM, but there are enhancements that are needed for improving performance.
How many years of programming experience does your team have on average? Also how many programming languages do you need to know on average to work on a project like this?
&gt; DirectX 12 is lacking the features of Vulkan  What specific features are you talking about?
&gt; What are "descriptor set pools"? From what I have read elsewhere, it's a special kind of memory heap to allocate descriptor sets for, but why would you need to reference the pool explicitly? In what kind of scenarios would you be using multiple pools? &gt; What was the rationale behind pipeline objects being serializable, what is the use case for this? Are serialized pipeline vendor/driver/device(context) specific?  Really good questions...these are still being actively discussed.  Join Khronos and help define the answer.
Thanks!
&gt; What does "querying the GPU memory requirements for images" entail? It sounded a bit like you would need to allocate memory from multiple pools for one image, is that the case? And when would an image require a different pool than usual, is it based on size?  The intent is the application manages GPU resources and the driver tells the app what GPU resources it needs for an object.
In regards to the SPIR-V stack of Vulkan/OpenCL, my understanding is that the driver should directly take the SPIR-V code and JIT that directly into machine code.    If we were to use the Gallium stack as a base, would SPIR-V be intended to replace the LLVM-IL based optimizer for the driver, the TGSI compile target, or both? I realize that it was not designed to fit into that stack per se, I am merely trying to understand were it fits.  Or, is that up to the individual drivers?
&gt; Will there be a distinction between textures and renderbuffers as offscreen rendertargets in Vulkan, or does that not make sense anymore on modern hardware? &gt;   Too early to tell...it's a topic of discussion.
Khronos says "this year"...if you know more than this...then please tell us.
When you say performance "needed" to improve, are you talking about some bottlenecks that cause it to currently underperform compared to OpenGL, or about optimizations that will blow OpenGL out of the water? 
Requirements are the same as OpenGL 4.3 / OpenGL ES 3.1 (about Direct3D 11 level graphics)
Do you honestly believe there will ever be a 'similar level of investment' for Linux that could possibly ever make it a mainstream gaming platform at least equal to windows?  I see many advantages of Linux but can't justify using it because it requires dual-booting because of the lack of support for games and a number of applications (particularly adobe). Especially when my mainboard takes a few minutes to post.  I think that it is very unlikely when you consider that big players like EA and Ubisoft will NEVER get behind a platform/API created by Valve.  
It's a simple matter of software...the real challenge is kernel level support...open source DRM vs closed source Windows kernel module.
:(  I really, really hope they can get Vulkan out before Windows 10/DX12 is widely adopted. If Vulkan can run on Windows 7+ like OpenGL currently does _and_ performs comparably to DX12, that has the potential to be absolutely huge. 
We would say that Vulkan is Gallium3D 2.0...it's even more explicit than Gallium3D today.
How about GLSL shader debugging (breakpoints, step in/out, watch variables, etc ... ) ? Will Vulkan/Spir-V helps to enable it ? I think it exists for HLSL in AMD's GpuPerfStudio and some people tried to do it for GLSL (https://github.com/GLSL-Debugger/GLSL-Debugger) but I couldn't make it to work...
Team members have 15+ years on average per engineer
thanks.
Not sure if this question fits your expectation: Vulkan and OpenCL 2.1 both use SPIR-V as IR. Does that mean that all Vendors which will support Vulkan will also have to support OpenCL? (looking at NVidia)
How many lines of code would it take to perform a "Hello Triangle" in Vulkan (compared to modern core OpenGL)? Of that, how much would you say is reusable?
SPIR-V can go on top of LLVM or TGSI.  LLVM is being used to optimize in our case.
Sorry, but it seems that you misunderstood my question. I was not asking where the act of opting into extensions was done, but whether the driver would have to validate the usage of extensions at run time because they might not have been opted in for.  Specifically what I'm thinking about are scenarios where the distinction between opted in and opted out would be more code than simply telling applications "if you don't want to use it, don't use it"; see my example about texture formats.
Yes, SPIR-V has debug info in it to enable debuggers.
No, they are different programming models.
I would if I wasn't a dirt poor student :) I guess I'll try asking Graham Sellers instead, he must know because he mentioned the pools in his slides.
Intel Gen 7 GPU (Ivy Bridge) [should support Vulkan too.](https://twitter.com/eodabash/status/573178560283717632)
We think about 600 lines of code, but you will reuse that code all the time.  Should be available in open source libraries making it easy to reuse. 
This is all speculation...we can't really add much here.
&gt; Also how many programming languages do you need to know on average to work on a project like this?  "Knowing many languages" is not really a thing in software development, at a certain level it is very important to understand core concepts and designs. Learning new programming languages is the same as learning new environments, it maybe takes a couple weeks but isn't something critical.
Ivy Bridge should in theory support that as well. It supports DirectX 11 with compute but, has no OpenGL 4.3 which is basically the same. It would be a matter of wanting to support OpenGL 4.3. Same should be true for Vulkan.
You are on the right track...
Sure.
Cool :) I have no idea how it would work but would the debugged values come from real execution on the gpu or would it come from cpu emulation ? 
How would SDL need to adapt to Vulkan? Will the be a VKUT (Vulkan Utility Library) just like we have GLUT?
[deleted]
The slides are very vague, but basically pipeline objects will encapsulate how the render pipeline is setup, ie. setting up most fixed-function parts of it like blend state, scissor state, depth/stencil state etc.. Sorry I can't explain it very well, I'm not a graphics programmer.
I was only asking for the personal opinions of people that are doing so much work towards achieving that goal, but ok.
The intent is to avoid unintended side effects. If you do not specify extension behavior, the app will not see that extension behavior. The driver might do the run time check at the driver level...or as a validation layer.  In the latter case...there won't be any production run time overhead.
[deleted]
Does this mean that SPIR-V is not a good optimization target, or would the benefits trickle down?
The intent is there will be validation layers both GPU independent and dependent that catch issues like this during development.
Isn't Gallium already a lot like Vulkan? Couldn't it be possible to change Gallium to be more like Vulkan, and then you get Gallium's OpenGL state tracker for free?  Bonus points if you replace NIR with SPIR-V entirely.
Thanks for doing this AMA:  1. Valve as a company focuses on the PC primarily. What do you think the adoption rate of Vulkan on consoles will be? Vulkan for PC is, in and of itself, not enough of a motivation to switch of D3D for a company already heavily invested in D3D for Windows/Xbox (and PS4 has its own API). 2. Khronos is, as an organization, much more closed than other similar non-profit committees (e.g. Standard C++ Foundation) that have open mailing lists and show proposals in flight. Do you imagine this will ever change? 3. Will GLAVE be open sourced?
Ah learning about the environments makes a lot more  sense than knowing a certain amount of programming languages. I never thought about it in that context. Thanks!
I was disappointed when I saw the Vulkan WSI doing things like "fullscreen". It seems like a poor combination of EGL and GLUT. I'd much prefer to see a binding where you get a Pixmap back and Present it manually to the X server / submit it as a wl_buffer to the Wayland compositor.  Have you talked about slimming back the WSI to barebones functionality rather than building a quasi-toolkit inside WSI?
Still they are closer today than ever. I hope someone will help them to push over (AMD, I am looking at you right now ;)
The OpenGL driver can use the 2D engine, but we can not in the way Vulkan API requires due to limitation in the current DRM driver. That said, we have gotten alot of mileage out of the current DRM implementation.
What languages are current tools able to compile down to SPIR-V? Obviously GLSL, and there was talk about LLVM&lt;-&gt;SPIR-V, but is there any chance of seeing a C++-&gt;SPIR-V compiler? Or HLSL? EDIT: Or some new language?  Is there any chance of getting a public draft vulkan specification or header file, similar to how we got the clearly WIP SPIR-V spec? Or is it going to only be a "when-it's-done" thing since it's a first release, not an update?
Yeah, for example when you have learned the basics of graphics hardware programming with Direct3D, learning OpenGL will be a much quicker walkthrough. You're no longer thinking "what does this mean", but "how do I do X/Y/Z in this specific API".  The same holds for programming languages, once you have the core concepts down all that learning a new language comes down to is "how do I define my methods / create my objects / create arrays" etc. instead of learning what all that means in the first place. If you know an imperative language like C++, learning D comes very simple.
Sadly, I think you may be overestimating the amount of effort someone who has an existing DX11 engine will be likely to put into porting to Vulkan instead of DX12.  
What are your plans for the [little chicken bit](http://lunarg.com/little-chicken-bit-story-big-performance-gain-intels-mesa-driver/)? When are you likely to release the code and do you expect it to be accepted upstream?
SPIR-V is designed to be a target for device independent optimizations.
How long do you think its going to take for driver vendors to implement the spec once its finalised. Like are we talking 2 years before we see games and quality drivers or much faster than that? The consensus from the Khronos talk seemed like the entire thing will more than likely be done and ready for mainstream by the end of the year. 
&gt; Will GLAVE be open sourced?  Yes!
Where in the h*** did you get that Vulkan UEFI association? Are you maybe confusing this with AtomBIOS?
It's best to ignore this guy in general.
From what we've seen of DX12, it seems much closer to Vulkan than to DX11, but honestly, I doubt people with custom engines will be adding Vulkan-on-Windows support anyway.
As opposed to device specific optimizations that would be applied at the IL to (insert asm equivalent here) optimizations.  Thanks, this was a distinction I was missing.   And thanks for this very helpful and informative AMA!!!
LunarG said earlier that they plan to release the open source Intel Linux driver the same day the spec becomes public :)  http://www.reddit.com/r/IAmA/comments/2ypils/we_are_lunarg_funded_by_valve_to_improve_steamos/cpbpv6o  
Thanks again guys! We had a blast.
But when there is a faster and more efficient standard available why would people use and develop the older one. Like for the moment obviously games currently are using OpenGL and both Wayland and Mir use EGL so they will be used but duplication of effort kind of makes me annoyed. For me I wouldn't just dump all the older work but I would only do maintenance releases and general improvements that wouldn't take huge effort.   Like can you explain why they are developing alongside Vulkan instead of sunsetting it slowly?
Well I mean more like when all the driver manufacturers get completely up to speed. 
 http://store.steampowered.com/steamos/buildyourown  &gt;What are the SteamOS Hardware Requirements?  &gt;...  &gt;**UEFI boot support**     So lighten up Francis. They said ask us pretty much anything. That release is based on the Debian core so I don't think the question is out of bounds. 
I mean, is it reasonable to expect that this will result in a dramatic reduction of complexity/maintenance effort for most drivers, as has been suggested in a lot of reporting?
Thank you for hanging by! Fingers crossed for Vulkan launch around autumn this year!
&gt; Using OpenGL just for the sake of simplicity sounds like poor man solution in this case because of the lack of alternaives (since major tradeoff is performance).  OpenGL is not a major tradeoff in performance if simplicity is a factor in your decision. If you're writing an application that just draws some 3D objects, as opposed to requiring a high level control over the exact rendering pipeline for maximizing performance, you don't need the complexity of Vulkan to do what you need.
How easy will it be to create bindings to statically typed languages? i.e. will there be horrible windows style variable length structs?
When do you recommend switchg to Vulkan as a devloper?
I have two questions (hopefully not dumb)  In many presentations HLSL was also mentioned. Referring to this article http://www.g-truc.net/post-0714.html  Slide 1 is suspiciously :) looking like how Unreal is doing things now, while other two clearly represent HLSL as possible input. Is this something already working or is this something that is yet to be implemented... or if?  Second question (partially related to HLSL) is if OpenGL will/could be possible target to work with SPIR-V IL. I can think something like Wine could benefit greatly
Can you make an AMD driver that doesn't suck for my older (7870 era) cards?
Not sure why you're being downvoted, this isn't just a Vulkan AMA judging off of the text box.
Are you guys hiring?  : P
My point is that OpenGL is still not ideal if something can be higher level than Vulkan while not compromising potential parallelisms capabilities. Of course simply nothing like that exists yet.  I guess most core projects like Wayland do care about performance enough to go with Vulkan route.
Good to know. Looks like Jolla tablet will be able to get Vulkan potentially then (since it uses Bay Trail which has the same GPU as Ivy Bridge).
Any chance of a reply to my two other questions?
In many cases at least as I see it, this is case of trading between easier development for harder Q&amp;A due to driver differences/core profiles supported on platforms/vendors  Time wise, not a good trade off
Is current Intel driver written by LunarG limited to specific Intel GPUs?
UEFI is a SteamOS Hardware Requirement. Vulkan is not specific to SteamOS.  Vulkan is intended to be used on mobile phones which do not have any type of standard such as this, at least not wide-spread. Vulkan itself has no such requirements.   An individual driver may have such a requirement outside of Vulkan, but that would have to do with the specific driver, and has nothing to do with Vulkan.  It should be noted that SteamOS is based on Debian, and you can pull the SteamOS bits onto a running Debian system, despite whatever BIOS subsytem it is running. So this "requirement" probably has something to do with either the provided installer will only deal with UEFI bios, which is simpler to support, and/or this is a requirement to get a SteamOS logo on your box. If the latter, this may be a sanity check on not using old hardware, since most motherboards now come with UEFI, and would prevent some truly bad/old/slow motherboard combinations.
Tech shaming? 
&gt; I guess most core projects like Wayland do care about performance enough to go with Vulkan route.  Unless the overhead of using OpenGL is not significant enough to warrant the additional complexity.
On mobile every bit of performance is significant because it increases battery life. So Wayland will care I hope.
Perhaps I misread the AMA, but I thought it said they were doing the Linux work in addition to the Vulkan API and SPIR-V. That's why I thought this was appropriate to ask here.  Thanks for the information though. While it's probably beyond my technical abilities, I might play around with what you suggested. Suppose it won't do any harm to try.  And I do get what you're saying about trying to weed out old hardware. But I have some boards from the mid 2000s with quad cores and NVidia cards that are still more than adequate for many of the games in my Steam library. It would be a shame if I can't use them simply because of the boot requirement.
You can take the developer out of COM, but you can't take the COM out of the developer.  
NIR and SPIR-V serve two entirely different purposes.
SPIR-V and NIR are both SSA-based IRs, and Connor Abbott worked on both :)
;)  The difference is that SPIR-V and NIR is that SPIR-V is designed as an interchange format whereas NIR is designed for doing actual optimizations (like LLVM). Once you look at the part of SPIR-V that's currently required for graphical shaders, they're otherwise very similar (use variables and SSA, structured control flow, represent graphics things natively, special code-motion rules for derivatives and textures, etc.). The SPIR-V you get isn't guaranteed to be optimized, though, so we'll probably still need NIR or something like it. OTOH, once you have to support pointers, unstructured control flow, etc., then you're probably better off with LLVM though, so we'll see what happens I guess...
Connor Abbott works on Khronos? That's pretty cool.  Nevertheless, SPIR-V is made to be a serialized on-disk format that you're just supposed to parse. NIR on the other hand was created specifically for all sorts of in-memory manipulations and optimizations.  I don't understand why so many people ask about unifying IRs, it's not like a single driver developer ever complained about them. Translating between IRs is not a terribly expensive operation.
Will you implement any support for HSA in your software?
LunarG reported the issue, but an Intel engineer actually solved the problem and sent [a kernel patch](http://lists.freedesktop.org/archives/intel-gfx/2014-October/054416.html) the next day.  The fix was [merged upstream](http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=944115934436b1ff6cf773a9e9123858ea9ef3da) recently - you need at least Linux v4.0-rc1.
Well, every driver developer ever complained about TGSI. The "bonus points" was more about stopping SPIR-V -&gt; NIR -&gt; TGSI -&gt; driver IR -&gt; driver code and instead going to SPIR-V -&gt; driver IR -&gt; driver code.
Do you have any plans to become more involved in the Mesa community, and land your work upstream?  Over the last year, LunarG only produced 26 Mesa commits, and only 1 of those appear to be performance related.  How would you respond to critics that claim college students and volunteers have done more to improve Linux 3D graphics performance in their spare time than your company has?
&gt; Well, every driver developer ever complained about TGSI.  Really? Do you have a mailing list post or article of a Gallium driver developer complaining about it? I'd like to read the points it brings up.  &gt; The "bonus points" was more about stopping SPIR-V -&gt; NIR -&gt; TGSI -&gt; driver IR -&gt; driver code and instead going to SPIR-V -&gt; driver IR -&gt; driver code.  Not considering that currently no driver uses both NIR and TGSI, what would be the problem with this? Is there some giant bottleneck in translating IRs that I am missing?
Perhaps you could put in a request for the linux gaming community,  maybe you could point out to valve that we should be able to download the games we've bought through steam even if its bot tagged for linux( I own over a hundred games on steam only two of which I can  download because they're the only ones specifically tagged for linux, after finding the games via other means I've gotten all 100 to run just fine but I'm sure you get my point :)? 
[deleted]
I don't know of any articles or interviews, but I worked together with a bunch of driver developers at Red Hat. Keep in mind that TGSI is a serialized wire format that's hard to work with, requires you to do a lot of analysis on, and has a "LIT" instruction in tyool2015.
Sure, but as you already pointed out it's a serialized format, nobody does any actual *work* on it, it's just the middleman between any state tracker frontend facing gallium and the gallium drivers, which immediately translate it to something workable (like LLVM for radeon). In that sense it's similar to SPIR-V, which you also don't want to run any passes on.
&gt; Really? Do you have a mailing list post or article of a Gallium driver developer complaining about it? I'd like to read the points it brings up.  I've talked to a few of them (informally on IRC) and the general feeling is "it's a little annoying, but not enough to do the work to rewrite it." Mainly the problem is that it loses a lot of type and layout information by converting everything to temporaries/virtual registers, and it isn't SSA. Of course, these issues are a lot less relevant if you already have a real compiler stack, but they don't go away entirely. TGSI inherits a lot from DX bytecode, so they both share these issues, and they were both things that SPIR-V explicitly set out to solve by doing things differently from DX.  So, is TGSI going to die? Unfortunately, I don't have a crystal ball here. Given that Vulkan is essentially "Gallium 2.0" and it looks like drivers will have to be re-written almost from scratch, it seems likely that people will write the glue necessary to make their compiler stack accept SPIR-V, so there could be momentum around it. But the inertia here is also pretty large and the existing stack is probably here to stay for quite some time, plus the CPU overhead from converting IR's is basically 0 so there's a lot more incentive to stick to TGSI than to rewrite all the N drivers that use it, so it could definitely stick around for quite a while.
I'm saying that the analysis pass is quite tricky and a lot of code, and it's not really a great IR, and SPIR-V is a lot better at giving you higher-level information to work with.
EA is a member of Khronos. And Dice seem eager to produce games for Linux. 
&gt; driver should directly take the SPIR-V code and JIT that directly into machine code.  Just a minor nitpick: JIT is typically used for a model where compilation time is mixed with execution time. SPIR-V is compiled into native during explicit compile calls that you can wait on to finish and then stash the result somewhere, as opposed to the current GL model where shaders are passed as buffers and shader compile can then happen at any time. In that sense, SPIR-V isn't really JITted.
The point about SPIR-V carrying a lot more contextual data is very fair (it looks more like a serialized form of GLSL than actual bytecode to me, with the control structures and such). However I think most people not involved with driver development who complain about "too many IRs" falsely assume that translation between them incurs a massive overhead that needs to be mitigated at all cost to stay "performant", so that irks me a little.
Well, if anything I would call it a serialized form of NIR :) And the OpenCL subset is serialized LLVM (but actually stable!) plus some OpenCL-specific things builtin. While it's true that translating IR's doesn't really have any CPU overhead, it is a little annoying that there are *so many* of them -- there's a little cognitive overhead :) and the root cause is that it's a lot easier to make new ones them then to remove old ones (I'm certainly guilty of this...) so nobody really bothers to clean up all the technical debt that's been accumulated -- Mesa IR is still a thing! seriously! -- although there have been a few efforts here and there.
[I don't see EA anywhere here.](http://en.wikipedia.org/wiki/Khronos_Group)  Also, it doesn't really matter what Dice WANT to do, it only matters what they are PAID to do by EA. 
[deleted]
Just run Steam in Wine to download your Windows games. You can usually run them that way too.
Rather than dual-booting, you can just install linux into a virtualPC in your windows box.   If nothing else It's worth doing just for secure web browsing.
When is half life 3 coming?
Yeah, I've done that a number of times aswell as headless linux servers for rdp (used as a torrentbox/media server).. but I've never really liked it because its not seamless like running a native application. I've really tried many times to adopt a number of different Linux flavours for a number of reasons but its never worked out. As for secure web browsing, I don't really care about my own web security so much, but I do have Tor installed for some things and if my PC ever gets infected, I've vanquished 1000s of viruses/malware over the years for other people so thts not really a concern I have either. I do make a sandbox whenever I know something I'm doing is going to be risky, but that's notoften enough to justify keeping one running 24/7.
Bay Trail's GPU cuts some features from Ivy Bridge. I'm not sure if the compute items needed were cut or not.
Here: https://www.khronos.org/members/contributors/electronic_arts_inc_ea
[deleted]
Valve has other contractors working that part of the stack.  And to answer the actual question, the .zip installer requires UEFI because booting off USB is bullshit. The .iso does not (and can be imaged to a USB stick; it is also a valid USB disk image - but you'll need to use dd if=/dev/zero of=/dev/myusbstickdevice to remove it again because reasons)
fair enough :)
There are 3 common ways to do this.  1) Use "SteamCMD", the server-specific Steam app. You can force it to download Windows versions of games.      directhex@marceline:/tmp/steamcmd$ curl -s http://media.steampowered.com/installer/steamcmd_linux.tar.gz | tar xzf -     directhex@marceline:/tmp/steamcmd$ ./steamcmd.sh +@sSteamCmdForcePlatformType windows +login anonymous +force_install_dir ./cs16dedicated +app_update 90 +quitRedirecting stderr to '/tmp/steamcmd/logs/stderr.txt'     [  0%] Checking for available updates...     [----] Verifying installation...     Steam Console Client (c) Valve Corporation     -- type 'quit' to exit --     Loading Steam API...OK.     "@sSteamCmdForcePlatformType" = "windows"          Connecting anonymously to Steam Public...Logged in OK     Waiting for license info...OK      Update state (0x3) reconfiguring, progress: 0.00 (0 / 0)      Update state (0x61) downloading, progress: 3.31 (734477 / 22171301)      Update state (0x61) downloading, progress: 93.99 (20837861 / 22171301)     Error! App '90' state is 0x6 after update job.     directhex@marceline:/tmp/steamcmd$ file cs16dedicated/hlds.exe      cs16dedicated/hlds.exe: PE32 executable (GUI) Intel 80386, for MS Windows  2) Locally override a game's app info to say it's cross-platform, so Steam downloads it. [Here](https://github.com/dotfloat/steam-appmanifest) is a tool to automate that.  3) Steam for Windows. [Here](https://lutris.net/) is a tool to automate that.
The Khronos website lists [EA](https://www.khronos.org/members/contributors/#electronic_arts_inc_ea).  Apparently they are "Contributors", which means they "have full API working group participation and voting rights, and generous marketing benefits"!
Didn't think to do it that way, thanks :) 
Any low-level work is gory and gruesome. The good news is that it only needs to be done once, made into a library, and everyone else can just use that library.
Maybe I'm in over my head here technically cause I'm not really understanding your answer. But if the .iso does not require UEFI, I'm still unclear why this remains a requirement for CD based installations. Or are you saying it's simply a requirement for USB installations and the requirement does not exist if obtaining the .iso image? Because I could have sworn I tried this months ago and got stopped by the UEFI requirement from a CD install.  And are you just saying to clear the USB disk partition table and boot sector with null characters after running an install image from it so it can be reused?    
&gt; Maybe I'm in over my head here technically cause I'm not really understanding your answer. But if the .iso does not require UEFI, I'm still unclear why this remains a requirement for CD based installations.  It isn't. http://steamcommunity.com/groups/steamuniverse/discussions/1/648817378243644036/  &gt;Or are you saying it's simply a requirement for USB installations and the requirement does not exist if obtaining the .iso image?  Correct  &gt; Because I could have sworn I tried this months ago and got stopped by the UEFI requirement from a CD install.  User error, then. The iso does NOT require UEFI. It has 4 boot loaders on it, 2 of them are for BIOS systems.  &gt; And are you just saying to clear the USB disk partition table and boot sector with null characters after running an install image from it so it can be reused?  Correct. Most tools will shit the bed at media with an isohybrid image on, including Windows Disk Manager and GParted. And it's partition tables plural, hence the problem.
Well geeze man, thanks. That would be great news. I'll have to go back and try again. I'm usually pretty good at the basic stuff, but I'm certainly not immune to making errors. Or maybe something has changed since I tried it a long time ago.  But again, thanks a lot for taking the time to answer.   Separately, I've actually had pretty good luck recovering media using [Rufus.](http://rufus.akeo.ie/)
Rufus is okay. Unetbootin is a cancer 
Figured you probably knew. Just figured I'd mention it.  And again, thanks for giving me an answer without treating me like an idiot for asking. 
That has been my experience as well...
[deleted]
They are not AMD...
Why in the world did steam console-ize their client on the pc? There is this dorky button that makes windows go away and replaces it with a hideously non-functional multi-media oriented front end from steam.  I hate this feature and if steam ever makes it somehow mandatory I'm gonna be extremely pissed. I have over a grand in games on steam I really need you guys to at least make the client work in a non-retarded way for PC users.  Why can't steam whore itself to the consolers without messing up my experience? I don't need or want STEAM to be an experience. It's just a client to support downloading and installing my games. That is all I want. Nothing MORE!!!  P.s. I'm talking about "big picture mode," or as I like to think of it "bloody stupid and retarded mode." Now my awesome gaming rig is reduced to a fucking playstation.
Looks like I'm a bit late to the party, but maybe someone reads it anyway:  I have an intel ivy bridge and a radeon gpu in my laptop. Currently, if I want to render on the radeon gpu, I set DRI_PRIME=1 (or to ID_PATH_TAG of my radeon gpu). How will I concretely do that with Vulkan on the radeon gpu?  If for some reason there will be no Vulkan support for Ivy Bridge: Will I still be able to use Vulkan on the radeon gpu?
Which is exactly why I think they might be able to make a driver that does not suck.
Thanks for the info. I'll try to find out.
I fucking hate when people downvote so their question can be seen.
Ha, I had this exact question but I missed the AMA
?? You aren't forced to use big picture mode. If you don't like the interface... Don't use it.
If they are already developing a Vulkan implementation of their engine for Linux/Android/Mac, why wouldn't they flip a switch to enable Vulkan support on Windows?  Have the same performance as your competitors that are stuck on Windows 10, but support even Vista, or maybe Windows XP. (Yes, I know that is unrealistic, since no vender still supports Windows XP. )
One of the selling points of Vulkan is that the driver implementation is really small. It shouldn't take long after the final spec is released.
&gt; Well, if anything I would call it a serialized form of NIR  Oh, that's interesting. I haven't looked much at NIR yet. But considering that you worked on SPIR-V too it makes a lot of sense ;)
Is this another area where common userspace libraries will handle the brunt of the work?
This is an old thread, but i just noticed it and i wanted to answer it anyway... while a core profile would be much easier and probably map much better to Vulkan, it will also be way less useful since the core profile is used by only a very tiny fraction of OpenGL programs and even programs that use the newer OpenGL features rarely restrict themselves to the core profile. Besides, most of the weird bugs would be on the compatibility profile features.  Personally i believe that we'll see a community driven effort to implement OpenGL on top of Vulkan and hopefully even allow access to the Vulkan API underneath (via a `EXT_Vulkan` extension or something like that). This would give developers the best of both worlds and as an open source project, bugs and edge cases would be fixed faster than waiting for a vendor to fix their own OpenGL implementation.  Of course as the parent said, it wouldn't be easy. But people have done harder stuff before.
Why exactly didn't you liked it? Have you tried KDE? I'm curious  recently I was needed to work with Windows, and it was a big pain to me, I wondered how I was using it before  it have no multiple desktops, primary clipboard, compose key with cool combinations from github, much better mouse management, visual fancies And I am really wonder why couldn't you adopt it. Perhaps did you used Unity? Just try a simple Kubuntu. 
